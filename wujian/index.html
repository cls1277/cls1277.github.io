<!DOCTYPE html>
<html lang="en" >

<head>
 <meta charset="UTF-8">

 <title>Merry Christmas</title>

 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">

 <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
 <meta name="mobile-web-app-capable" content="yes">
 <meta name="apple-mobile-web-app-capable" content="yes">
 <meta name="theme-color" content="#000000">
 <!-- <link rel="shortcut icon" type="image/png" href="assets/image/firework-burst-icon-v2.png"> -->
 <!-- <link rel="icon" type="image/png" href="assets/image/firework-burst-icon-v2.png"> -->
 <!-- <link rel="apple-touch-icon-precomposed" href="assets/image/firework-burst-icon-v2.png"> -->
 <meta name="msapplication-TileColor" content="#000000">
 <!-- <meta name="msapplication-TileImage" content="assets/image/firework-burst-icon-v2.png"> -->
 <link href="https://fonts.googleapis.com/css?family=Russo+One" rel="stylesheet">
 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css">
 <link rel="stylesheet" href="assets/css/style.css">
 <link rel="stylesheet" href="assets/css/style_tree.css">

 <script>
  window.console = window.console || function(t) {};
 </script>

 <script>
  if (document.location.search.match(/type=embed/gi)) {
   window.parent.postMessage("resize", "*");
  }
 </script>


</head>

<body translate="no" >
 <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/EffectComposer.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/RenderPass.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/ShaderPass.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/shaders/CopyShader.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
 
 <div style="height: 0; width: 0; position: absolute; visibility: hidden;">
  <svg xmlns="http://www.w3.org/2000/svg">
      <symbol id="icon-play" viewBox="0 0 24 24">
          <path d="M8 5v14l11-7z"/>
      </symbol>
      <symbol id="icon-pause" viewBox="0 0 24 24">
          <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
      </symbol>
      <symbol id="icon-close" viewBox="0 0 24 24">
          <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
      </symbol>
      <symbol id="icon-settings" viewBox="0 0 24 24">
          <path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/>
      </symbol>
      <symbol id="icon-sound-on" viewBox="0 0 24 24">
          <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
      </symbol>
      <symbol id="icon-sound-off" viewBox="0 0 24 24">
          <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
      </symbol>
  </svg>
</div>

 <div id="overlay">
  <ul>
   <!-- <li class="separator">Music</li> -->
   <li><button class="btntree" id="btnB" type="button">Ms. Wu, click me!</button></li>
   <!-- <li class="separator">or</li> -->
   <li>
    <input type="file" id="upload" hidden />
    <label for="upload" hidden>Upload File</label>
   </li>
  </ul>
 </div>

 <script id="rendered-js" >

  const { PI, sin, cos } = Math;
  const TAU = 2 * PI;

  const map = (value, sMin, sMax, dMin, dMax) => {
   return dMin + (value - sMin) / (sMax - sMin) * (dMax - dMin);
  };

  const range = (n, m = 0) =>
  Array(n).
  fill(m).
  map((i, j) => i + j);

  const rand = (max, min = 0) => min + Math.random() * (max - min);
  const randInt = (max, min = 0) => Math.floor(min + Math.random() * (max - min));
  const randChoise = arr => arr[randInt(arr.length)];
  const polar = (ang, r = 1) => [r * cos(ang), r * sin(ang)];

  let scene, camera, renderer, analyser;
  let step = 0;
  const uniforms = {
   time: { type: "f", value: 0.0 },
   step: { type: "f", value: 0.0 } };

   const params = {
    exposure: 1,
    bloomStrength: 0.9,
    bloomThreshold: 0,
    bloomRadius: 0.5 };

    let composer;

    const fftSize = 2048;
    const totalPoints = 4000;

    const listener = new THREE.AudioListener();

    const audio = new THREE.Audio(listener);

    document.querySelector("input").addEventListener("change", uploadAudio, false);

    const buttons = document.querySelectorAll(".btntree");
    buttons.forEach((button, index) =>
     button.addEventListener("click", () => loadAudio(index)));

    function init() {
     const overlay = document.getElementById("overlay");
     overlay.remove();

     scene = new THREE.Scene();
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
     document.body.appendChild(renderer.domElement);

     camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      1,
      1000);

     camera.position.set(-0.09397456774197047, -2.5597086635726947, 24.420789670889008);
     camera.rotation.set(0.10443543723052419, -0.003827152981119352, 0.0004011488708739715);

     const format = renderer.capabilities.isWebGL2 ?
     THREE.RedFormat :
     THREE.LuminanceFormat;

     uniforms.tAudioData = {
      value: new THREE.DataTexture(analyser.data, fftSize / 2, 1, format) };


      addPlane(scene, uniforms, 3000);
      addSnow(scene, uniforms);
      addFirework(scene, uniforms);

      range(10).map(i => {
       addTree(scene, uniforms, totalPoints, [20, 0, -20 * i]);
       addTree(scene, uniforms, totalPoints, [-20, 0, -20 * i]);
      });

      const renderScene = new THREE.RenderPass(scene, camera);

      const bloomPass = new THREE.UnrealBloomPass(
       new THREE.Vector2(window.innerWidth, window.innerHeight),
       1.5,
       0.4,
       0.85);

      bloomPass.threshold = params.bloomThreshold;
      bloomPass.strength = params.bloomStrength;
      bloomPass.radius = params.bloomRadius;

      composer = new THREE.EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);

      addListners(camera, renderer, composer);
      animate();
     }

     function animate(time) {
      analyser.getFrequencyData();
      uniforms.tAudioData.value.needsUpdate = true;
      step = (step + 1) % 1000;
      uniforms.time.value = time;
      uniforms.step.value = step;
      composer.render();
      requestAnimationFrame(animate);
     }

     function loadAudio(i) {
      document.getElementById("overlay").innerHTML =
      '<div class="text-loading">Loading music...</div>';
      const files = [
      "https://files.freemusicarchive.org/storage-freemusicarchive-org/music/no_curator/Dott/This_Christmas/Dott_-_01_-_This_Christmas.mp3"];

      const file = files[i];
      const loader = new THREE.AudioLoader();
      loader.load(file, function (buffer) {
       audio.setBuffer(buffer);
       audio.play();
       analyser = new THREE.AudioAnalyser(audio, fftSize);
       init();
      });


     }

     function uploadAudio(event) {
      document.getElementById("overlay").innerHTML =
      '<div class="text-loading">请稍等...</div>';
      const files = event.target.files;
      const reader = new FileReader();

      reader.onload = function (file) {
       var arrayBuffer = file.target.result;

       listener.context.decodeAudioData(arrayBuffer, function (audioBuffer) {
        audio.setBuffer(audioBuffer);
        audio.play();
        analyser = new THREE.AudioAnalyser(audio, fftSize);
        init();
       });
      };

      reader.readAsArrayBuffer(files[0]);
     }

     function addTree(scene, uniforms, totalPoints, treePosition) {
      const vertexShader = `
      attribute float mIndex;
      varying vec3 vColor;
      varying float opacity;
      uniform sampler2D tAudioData;

      float norm(float value, float min, float max ){
       return (value - min) / (max - min);
      }
      float lerp(float norm, float min, float max){
       return (max - min) * norm + min;
      }

      float map(float value, float sourceMin, float sourceMax, float destMin, float destMax){
       return lerp(norm(value, sourceMin, sourceMax), destMin, destMax);
      }


      void main() {
       vColor = color;
       vec3 p = position;
       vec4 mvPosition = modelViewMatrix * vec4( p, 1.0 );
       float amplitude = texture2D( tAudioData, vec2( mIndex, 0.1 ) ).r;
       float amplitudeClamped = clamp(amplitude-0.4,0.0, 0.6 );
       float sizeMapped = map(amplitudeClamped, 0.0, 0.6, 1.0, 20.0);
       opacity = map(mvPosition.z , -200.0, 15.0, 0.0, 1.0);
       gl_PointSize = sizeMapped * ( 100.0 / -mvPosition.z );
       gl_Position = projectionMatrix * mvPosition;
      }
      `;
      const fragmentShader = `
      varying vec3 vColor;
      varying float opacity;
      uniform sampler2D pointTexture;
      void main() {
       gl_FragColor = vec4( vColor, opacity );
       gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord ); 
      }
      `;
      const shaderMaterial = new THREE.ShaderMaterial({
       uniforms: {
        ...uniforms,
        pointTexture: {
         value: new THREE.TextureLoader().load(`https://assets.codepen.io/3685267/spark1.png`) } },


         vertexShader,
         fragmentShader,
         blending: THREE.AdditiveBlending,
         depthTest: false,
         transparent: true,
         vertexColors: true });


      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      const sizes = [];
      const phases = [];
      const mIndexs = [];

      const color = new THREE.Color();

      for (let i = 0; i < totalPoints; i++) {
       const t = Math.random();
       const y = map(t, 0, 1, -8, 10);
       const ang = map(t, 0, 1, 0, 6 * TAU) + TAU / 2 * (i % 2);
       const [z, x] = polar(ang, map(t, 0, 1, 5, 0));

       const modifier = map(t, 0, 1, 1, 0);
       positions.push(x + rand(-0.3 * modifier, 0.3 * modifier));
       positions.push(y + rand(-0.3 * modifier, 0.3 * modifier));
       positions.push(z + rand(-0.3 * modifier, 0.3 * modifier));

       color.setHSL(map(i, 0, totalPoints, 1.0, 0.0), 1.0, 0.5);

       colors.push(color.r, color.g, color.b);
       phases.push(rand(1000));
       sizes.push(1);
       const mIndex = map(i, 0, totalPoints, 1.0, 0.0);
       mIndexs.push(mIndex);
      }

      geometry.setAttribute(
       "position",
       new THREE.Float32BufferAttribute(positions, 3).setUsage(
        THREE.DynamicDrawUsage));


      geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
      geometry.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));
      geometry.setAttribute("phase", new THREE.Float32BufferAttribute(phases, 1));
      geometry.setAttribute("mIndex", new THREE.Float32BufferAttribute(mIndexs, 1));

      const tree = new THREE.Points(geometry, shaderMaterial);

      const [px, py, pz] = treePosition;

      tree.position.x = px;
      tree.position.y = py;
      tree.position.z = pz;

      scene.add(tree);
     }

     function addSnow(scene, uniforms) {
      const vertexShader = `
      attribute float size;
      attribute float phase;
      attribute float phaseSecondary;

      varying vec3 vColor;
      varying float opacity;


      uniform float time;
      uniform float step;

      float norm(float value, float min, float max ){
       return (value - min) / (max - min);
      }
      float lerp(float norm, float min, float max){
       return (max - min) * norm + min;
      }

      float map(float value, float sourceMin, float sourceMax, float destMin, float destMax){
       return lerp(norm(value, sourceMin, sourceMax), destMin, destMax);
      }
      void main() {
       float t = time* 0.0006;

       vColor = color;

       vec3 p = position;

       p.y = map(mod(phase+step, 1000.0), 0.0, 1000.0, 25.0, -8.0);

       p.x += sin(t+phase);
       p.z += sin(t+phaseSecondary);

       opacity = map(p.z, -150.0, 15.0, 0.0, 1.0);

       vec4 mvPosition = modelViewMatrix * vec4( p, 1.0 );

       gl_PointSize = size * ( 100.0 / -mvPosition.z );

       gl_Position = projectionMatrix * mvPosition;

      }
      `;

      const fragmentShader = `
      uniform sampler2D pointTexture;
      varying vec3 vColor;
      varying float opacity;

      void main() {
       gl_FragColor = vec4( vColor, opacity );
       gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord ); 
      }
      `;
      function createSnowSet(sprite) {
       const totalPoints = 300;
       const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: {
         ...uniforms,
         pointTexture: {
          value: new THREE.TextureLoader().load(sprite) } },


          vertexShader,
          fragmentShader,
          blending: THREE.AdditiveBlending,
          depthTest: false,
          transparent: true,
          vertexColors: true });


       const geometry = new THREE.BufferGeometry();
       const positions = [];
       const colors = [];
       const sizes = [];
       const phases = [];
       const phaseSecondaries = [];

       const color = new THREE.Color();

       for (let i = 0; i < totalPoints; i++) {
        const [x, y, z] = [rand(25, -25), 0, rand(15, -150)];
        positions.push(x);
        positions.push(y);
        positions.push(z);

        color.set(randChoise(["#f1d4d4", "#f1f6f9", "#eeeeee", "#f1f1e8"]));

        colors.push(color.r, color.g, color.b);
        phases.push(rand(1000));
        phaseSecondaries.push(rand(1000));
        sizes.push(rand(4, 2));
       }

       geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(positions, 3));

       geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
       geometry.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));
       geometry.setAttribute("phase", new THREE.Float32BufferAttribute(phases, 1));
       geometry.setAttribute(
        "phaseSecondary",
        new THREE.Float32BufferAttribute(phaseSecondaries, 1));


       const mesh = new THREE.Points(geometry, shaderMaterial);

       scene.add(mesh);
      }
      const sprites = [
      "https://assets.codepen.io/3685267/snowflake1.png",
      "https://assets.codepen.io/3685267/snowflake2.png",
      "https://assets.codepen.io/3685267/snowflake3.png",
      "https://assets.codepen.io/3685267/snowflake4.png"];

      sprites.forEach(sprite => {
       createSnowSet(sprite);
      });
     }

     function addFirework(scene, uniforms) {
      const vertexShader = `
      attribute float size;
      attribute float phase;
      attribute float phaseSecondary;

      varying vec3 vColor;
      varying float opacity;


      uniform float time;
      uniform float step;

      float norm(float value, float min, float max ){
       return (value - min) / (max - min);
      }
      float lerp(float norm, float min, float max){
       return (max - min) * norm + min;
      }
       float rand(float seed) {
          return fract(sin(seed * 43758.5453) * 10000.0); 
      }

      float map(float value, float sourceMin, float sourceMax, float destMin, float destMax){
       return lerp(norm(value, sourceMin, sourceMax), destMin, destMax);
      }
      void main() {
       float t = time* 0.0006;

      //  vColor = color;
          float flashToggle = sin(t + phase * 0.5);  // 控制闪烁的周期
    flashToggle = (flashToggle + 1.0) * 0.5;  // 映射到 [0, 1] 范围
       if (flashToggle > 0.5) {
        vColor = color;  // 如果闪烁因子大于0.5，使用原始颜色
        } else {
            vColor = vec3(0.0, 0.0, 0.0);  // 如果闪烁因子小于0.5，使用黑色
        }

       vec3 p = position;

      //  p.y = map(mod(phase+step, 1000.0), 1000.0, 0.0, 25.0, -8.0);

        // 当粒子到达最高点后，模拟爆炸效果
        float explosionHeight = 15.0;  // 设置烟花的最大升高点
        float maxHeight = 25.0;  // 设定烟花爆炸的最终高度
        if (p.y >= explosionHeight) {
            // 当粒子到达爆炸高度，开始模拟爆炸扩散
            float explosionFactor = map(p.y, explosionHeight, maxHeight, 1.0, 3.0);
            
            // 在 x 和 z 轴上扩散粒子位置，模拟烟花爆炸
            p.x += rand(phase) * explosionFactor * 2.0 - 1.0;  // 随机方向的x轴扩散
            p.z += rand(phase + 1000.0) * explosionFactor * 2.0 - 1.0;  // 随机方向的z轴扩散
        }

        // 调整粒子大小，模拟在烟花绽放时粒子增大的效果
        float sizeMultiplier = 1.0;
        if (p.y >= explosionHeight) {
          sizeMultiplier = map(p.y, explosionHeight, maxHeight, 1.0, 3.0);
        }

      //  p.x += sin(t+phase);
       p.z += sin(t+phaseSecondary);

       opacity = map(p.z-20.0, -150.0, 15.0, 0.0, 1.0);

       vec4 mvPosition = modelViewMatrix * vec4( p, 1.0 );

       gl_PointSize = size * sizeMultiplier * ( 100.0 / -mvPosition.z );

       gl_Position = projectionMatrix * mvPosition;

      }
      `;

      const fragmentShader = `
      uniform sampler2D pointTexture;
      varying vec3 vColor;
      varying float opacity;

      void main() {
       gl_FragColor = vec4( vColor, opacity );
       gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord ); 
      }
      `;
      function createSnowSet(sprite) {
       const totalPoints = 100;
       const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: {
         ...uniforms,
         pointTexture: {
          value: new THREE.TextureLoader().load(sprite) } },


          vertexShader,
          fragmentShader,
          blending: THREE.AdditiveBlending,
          depthTest: false,
          transparent: true,
          vertexColors: true });


       const geometry = new THREE.BufferGeometry();
       const positions = [];
       const colors = [];
       const sizes = [];
       const phases = [];
       const phaseSecondaries = [];

       const color = new THREE.Color();

       for (let i = 0; i < totalPoints; i++) {
        // const [x, y, z] = [rand(25, -25), rand(30, 50), -50];
        const [x, y, z] = [rand(100, -100), rand(30, 50), rand(15, -150)];
        positions.push(x);
        positions.push(y);
        positions.push(z);

        color.set(randChoise(["#ffff00"]));

        colors.push(color.r, color.g, color.b);
        phases.push(rand(1000));
        phaseSecondaries.push(rand(1000));
        // sizes.push(rand(4, 2));
        sizes.push(6);
       }

       geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(positions, 3));

       geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
       geometry.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));
       geometry.setAttribute("phase", new THREE.Float32BufferAttribute(phases, 1));
       geometry.setAttribute(
        "phaseSecondary",
        new THREE.Float32BufferAttribute(phaseSecondaries, 1));


       const mesh = new THREE.Points(geometry, shaderMaterial);

       scene.add(mesh);
      }
      const sprites = [
      "https://assets.codepen.io/3685267/snowflake5.png"];
      // "https://assets.codepen.io/3685267/snowflake2.png"];
      // "https://assets.codepen.io/3685267/snowflake3.png"];
      // "https://assets.codepen.io/3685267/snowflake4.png"];
      // "https://assets.codepen.io/3685267/snowflake5.png"];

      sprites.forEach(sprite => {
       createSnowSet(sprite);
      });
     }

     function addPlane(scene, uniforms, totalPoints) {
      const vertexShader = `
      attribute float size;
      attribute vec3 customColor;
      varying vec3 vColor;

      void main() {
       vColor = customColor;
       vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
       gl_PointSize = size * ( 300.0 / -mvPosition.z );
       gl_Position = projectionMatrix * mvPosition;

      }
      `;
      const fragmentShader = `
      uniform vec3 color;
      uniform sampler2D pointTexture;
      varying vec3 vColor;

      void main() {
       gl_FragColor = vec4( vColor, 1.0 );
       gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );

      }
      `;
      const shaderMaterial = new THREE.ShaderMaterial({
       uniforms: {
        ...uniforms,
        pointTexture: {
         value: new THREE.TextureLoader().load(`https://assets.codepen.io/3685267/spark1.png`) } },


         vertexShader,
         fragmentShader,
         blending: THREE.AdditiveBlending,
         depthTest: false,
         transparent: true,
         vertexColors: true });


      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      const sizes = [];

      const color = new THREE.Color();

      for (let i = 0; i < totalPoints; i++) {
       const [x, y, z] = [rand(-25, 25), 0, rand(-150, 15)];
       positions.push(x);
       positions.push(y);
       positions.push(z);

       color.set(randChoise(["#93abd3", "#f2f4c0", "#9ddfd3"]));

       colors.push(color.r, color.g, color.b);
       sizes.push(1);
      }

      geometry.setAttribute(
       "position",
       new THREE.Float32BufferAttribute(positions, 3).setUsage(
        THREE.DynamicDrawUsage));


      geometry.setAttribute(
       "customColor",
       new THREE.Float32BufferAttribute(colors, 3));

      geometry.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));

      const plane = new THREE.Points(geometry, shaderMaterial);

      plane.position.y = -8;
      scene.add(plane);
     }

     function addListners(camera, renderer, composer) {
      document.addEventListener("keydown", e => {
       const { x, y, z } = camera.position;
       console.log(`camera.position.set(${x},${y},${z})`);
       const { x: a, y: b, z: c } = camera.rotation;
       console.log(`camera.rotation.set(${a},${b},${c})`);
      });

      window.addEventListener(
       "resize",
       () => {
        const width = window.innerWidth;
        const height = window.innerHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        composer.setSize(width, height);
       },
       false);

     }
</script>

</body>

</html>